<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Labirinto 3D</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a0a0a;
      color: #fff;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas {
      display: block;
    }
    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.65);
      padding: 16px 20px;
      border-radius: 10px;
      max-width: 300px;
      line-height: 1.5;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    #overlay.hidden {
      opacity: 0;
    }
    #instructions {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.75);
      gap: 12px;
      text-align: center;
    }
    #instructions button {
      pointer-events: auto;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      background: #00c6ff;
      color: #111;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    #instructions button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(0, 198, 255, 0.45);
    }
    #victory {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.85);
      text-align: center;
      gap: 12px;
      font-size: 1.5rem;
    }
    #victory button {
      border: none;
      padding: 12px 26px;
      border-radius: 6px;
      background: #66ff66;
      color: #111;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    #victory button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(102, 255, 102, 0.45);
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h1>Labirinto 3D</h1>
    <p>Use o mouse para mirar e WASD ou setas para se mover.</p>
    <p>Chegue ao portal luminoso para vencer.</p>
    <button id="startBtn">Começar</button>
  </div>
  <div id="overlay">Objetivo: alcance o portal luminoso.</div>
  <div id="victory">
    <h2>Você escapou!</h2>
    <p>Pressione reiniciar para tentar novamente.</p>
    <button id="restartBtn">Reiniciar</button>
  </div>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
    import { PointerLockControls } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/controls/PointerLockControls.js";

    const mazeLayout = [
      "###############",
      "#S000#0000000E#",
      "#0#0#0###0###0#",
      "#0#0#000#00000#",
      "#0###0#####0#0#",
      "#00000#000#0#0#",
      "###0###0#0#0#0#",
      "#0000000#0#0#0#",
      "#0#####0#0#0#0#",
      "#0#0000000#0#0#",
      "#0#0#####0#0#0#",
      "#0#0000#0000#0#",
      "#0#####0#####0#",
      "#0000000000000#",
      "###############"
    ];

    const cellSize = 6;
    const wallHeight = 4;
    const playerHeight = 2;
    const moveSpeed = 8;
    const collisionRadius = 1.3;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020202);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 30);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    const floorGeo = new THREE.PlaneGeometry(mazeLayout[0].length * cellSize, mazeLayout.length * cellSize);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x1f1f1f,
      roughness: 0.8,
      metalness: 0.2
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const wallGeo = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x113344, roughness: 0.5 });

    const walls = [];
    let startPosition = new THREE.Vector3();
    let exitPosition = new THREE.Vector3();

    const halfWidth = (mazeLayout[0].length * cellSize) / 2;
    const halfHeight = (mazeLayout.length * cellSize) / 2;

    mazeLayout.forEach((row, zIndex) => {
      [...row].forEach((cell, xIndex) => {
        const x = xIndex * cellSize - halfWidth + cellSize / 2;
        const z = zIndex * cellSize - halfHeight + cellSize / 2;

        if (cell === "#") {
          const wall = new THREE.Mesh(wallGeo, wallMat);
          wall.castShadow = true;
          wall.receiveShadow = true;
          wall.position.set(x, wallHeight / 2, z);
          scene.add(wall);
          walls.push(wall);
        } else if (cell === "S") {
          startPosition.set(x, playerHeight, z);
        } else if (cell === "E") {
          exitPosition.set(x, 1.5, z);
        }
      });
    });

    const exitGeometry = new THREE.RingGeometry(1, 2, 32);
    const exitMaterial = new THREE.MeshBasicMaterial({ color: 0x66ffcc, side: THREE.DoubleSide });
    const exitPortal = new THREE.Mesh(exitGeometry, exitMaterial);
    exitPortal.position.copy(exitPosition);
    exitPortal.rotation.y = Math.PI / 2;
    scene.add(exitPortal);

    const portalLight = new THREE.PointLight(0x66ffcc, 1.5, 20, 2);
    portalLight.position.copy(exitPosition);
    portalLight.position.y += 1.5;
    scene.add(portalLight);

    const controls = new PointerLockControls(camera, document.body);

    const instructions = document.getElementById("instructions");
    const overlay = document.getElementById("overlay");
    const startBtn = document.getElementById("startBtn");
    const victoryScreen = document.getElementById("victory");
    const restartBtn = document.getElementById("restartBtn");

    function resetPlayer() {
      controls.getObject().position.copy(startPosition);
      controls.getObject().position.y = playerHeight;
      camera.rotation.set(0, 0, 0);
      victoryScreen.style.display = "none";
    }

    startBtn.addEventListener("click", () => {
      controls.lock();
    });

    restartBtn.addEventListener("click", () => {
      victoryScreen.style.display = "none";
      overlay.classList.remove("hidden");
      controls.lock();
      resetPlayer();
    });

    controls.addEventListener("lock", () => {
      instructions.style.display = "none";
      overlay.classList.remove("hidden");
      if (!controls.isLocked) {
        resetPlayer();
      }
    });

    controls.addEventListener("unlock", () => {
      instructions.style.display = "flex";
      overlay.classList.add("hidden");
    });

    scene.add(controls.getObject());
    resetPlayer();

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    const keys = {
      forward: false,
      backward: false,
      left: false,
      right: false
    };

    function onKeyDown(event) {
      switch (event.code) {
        case "ArrowUp":
        case "KeyW":
          keys.forward = true;
          break;
        case "ArrowLeft":
        case "KeyA":
          keys.left = true;
          break;
        case "ArrowDown":
        case "KeyS":
          keys.backward = true;
          break;
        case "ArrowRight":
        case "KeyD":
          keys.right = true;
          break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case "ArrowUp":
        case "KeyW":
          keys.forward = false;
          break;
        case "ArrowLeft":
        case "KeyA":
          keys.left = false;
          break;
        case "ArrowDown":
        case "KeyS":
          keys.backward = false;
          break;
        case "ArrowRight":
        case "KeyD":
          keys.right = false;
          break;
      }
    }

    document.addEventListener("keydown", onKeyDown);
    document.addEventListener("keyup", onKeyUp);

    const clock = new THREE.Clock();

    function detectCollisions(newPosition) {
      const playerBox = new THREE.Sphere(newPosition, collisionRadius);
      for (const wall of walls) {
        const wallBox = new THREE.Box3().setFromObject(wall);
        if (wallBox.distanceToPoint(playerBox.center) <= collisionRadius) {
          return true;
        }
      }
      return false;
    }

    function checkVictory() {
      const playerPos = controls.getObject().position;
      const distance = playerPos.distanceTo(exitPosition);
      if (distance < 2.2) {
        victoryScreen.style.display = "flex";
        overlay.classList.add("hidden");
        controls.unlock();
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      velocity.set(0, 0, 0);

      if (controls.isLocked) {
        direction.set(0, 0, 0);
        if (keys.forward) direction.z -= 1;
        if (keys.backward) direction.z += 1;
        if (keys.left) direction.x -= 1;
        if (keys.right) direction.x += 1;

        if (direction.lengthSq() > 0) {
          direction.normalize();
          const quaternion = controls.getObject().quaternion.clone();
          const move = direction.applyQuaternion(quaternion).multiplyScalar(moveSpeed * delta);

          const currentPos = controls.getObject().position.clone();
          const proposedPos = currentPos.clone().add(move);

          if (!detectCollisions(proposedPos)) {
            controls.getObject().position.copy(proposedPos);
          } else {
            // Attempt to slide along individual axes
            const axisAttemptX = currentPos.clone().add(new THREE.Vector3(move.x, 0, 0));
            const axisAttemptZ = currentPos.clone().add(new THREE.Vector3(0, 0, move.z));

            if (!detectCollisions(axisAttemptX)) {
              controls.getObject().position.copy(axisAttemptX);
            } else if (!detectCollisions(axisAttemptZ)) {
              controls.getObject().position.copy(axisAttemptZ);
            }
          }
        }
        checkVictory();
      }

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
